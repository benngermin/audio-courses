# Passwordless Magic Link Authentication Implementation Guide

## Overview
This document provides a complete implementation guide for a passwordless magic link authentication system using Flask, SQLAlchemy, and Resend email service. The system implements just-in-time (JIT) user provisioning, meaning user accounts are created automatically on first login.

## Key Features
- **Passwordless Authentication**: No passwords to manage or reset
- **Magic Link Login**: Secure, time-limited login links sent via email
- **Just-In-Time User Provisioning**: Accounts created automatically on first successful login
- **Session Management**: Secure cookie-based sessions with 30-day expiration
- **Rate Limiting**: Protection against abuse with per-email and per-IP limits
- **Security Features**: Token hashing, CSRF protection, secure cookies
- **Production-Ready**: Environment detection for development vs production URLs

## Technology Stack

### Backend Dependencies
```toml
# Core Framework
flask>=3.1.1
flask-sqlalchemy>=3.1.1
werkzeug>=3.1.3

# Database
psycopg2-binary>=2.9.10
sqlalchemy>=2.0.42

# Email Service
resend>=2.12.0

# Validation
pydantic>=2.11.7
email-validator>=2.2.0

# Server
gunicorn>=23.0.0
```

### Frontend Dependencies
- Bootstrap 5.3.0 (CSS Framework)
- Font Awesome 6.4.0 (Icons)
- Vanilla JavaScript (No framework required)

## Project Structure
```
├── auth_routes.py      # Authentication endpoints and logic
├── auth_models.py      # Database models for auth system
├── auth_utils.py       # Authentication utilities and helpers
├── email_service.py    # Email sending functionality
├── database.py         # Database configuration
├── templates/
│   ├── login.html      # Login page template
│   └── auth_error.html # Error page for auth issues
└── app.py              # Main application file
```

## Database Schema

### 1. User Table
Stores user account information with minimal data (email only).

```python
class User(db.Model):
    """Model for user accounts"""
    id = db.Column(db.String(36), primary_key=True)  # UUID
    email = db.Column(db.String(255), unique=True, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
```

### 2. MagicLinkToken Table
Stores magic link tokens with security metadata.

```python
class MagicLinkToken(db.Model):
    """Model for magic link tokens"""
    id = db.Column(db.String(36), primary_key=True)  # UUID
    email = db.Column(db.String(255), nullable=False)
    token_hash = db.Column(db.String(64), unique=True, nullable=False)  # SHA-256 hash
    expires_at = db.Column(db.DateTime, nullable=False)
    consumed_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    created_ip = db.Column(db.String(45), nullable=True)  # IPv6 compatible
    user_agent = db.Column(db.Text, nullable=True)
```

### 3. Session Table
Manages user sessions with expiration.

```python
class Session(db.Model):
    """Model for user sessions"""
    id = db.Column(db.String(64), primary_key=True)  # Base64url encoded session ID
    user_id = db.Column(db.String(36), db.ForeignKey('user.id'), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    
    # Relationship
    user = db.relationship('User', backref=db.backref('sessions', lazy=True))
```

### 4. RateLimit Table
Implements hour-based rate limiting.

```python
class RateLimit(db.Model):
    """Model for rate limiting (hour buckets)"""
    key = db.Column(db.String(255), primary_key=True)  # e.g., "send:email:<email>" or "send:ip:<ip>"
    window_start = db.Column(db.DateTime, nullable=False)
    count = db.Column(db.Integer, nullable=False, default=0)
```

## Core Implementation Files

### 1. Database Configuration (database.py)
Sets up SQLAlchemy with Flask.

```python
import os
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass

db = SQLAlchemy(model_class=Base)
```

### 2. Authentication Models (auth_models.py)
Complete file with all database models:

```python
from database import db
from datetime import datetime
import json

class User(db.Model):
    """Model for user accounts"""
    id = db.Column(db.String(36), primary_key=True)  # Will use UUID
    email = db.Column(db.String(255), unique=True, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<User {self.email}>'

class MagicLinkToken(db.Model):
    """Model for magic link tokens"""
    id = db.Column(db.String(36), primary_key=True)  # Will use UUID
    email = db.Column(db.String(255), nullable=False)
    token_hash = db.Column(db.String(64), unique=True, nullable=False)  # SHA-256 hash
    expires_at = db.Column(db.DateTime, nullable=False)
    consumed_at = db.Column(db.DateTime, nullable=True)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    created_ip = db.Column(db.String(45), nullable=True)  # IPv6 compatible
    user_agent = db.Column(db.Text, nullable=True)
    
    def __repr__(self):
        return f'<MagicLinkToken {self.email}>'

class Session(db.Model):
    """Model for user sessions"""
    id = db.Column(db.String(64), primary_key=True)  # Base64url encoded session ID
    user_id = db.Column(db.String(36), db.ForeignKey('user.id'), nullable=False)
    expires_at = db.Column(db.DateTime, nullable=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    
    # Relationship
    user = db.relationship('User', backref=db.backref('sessions', lazy=True))
    
    def __repr__(self):
        return f'<Session {self.user_id}>'

class RateLimit(db.Model):
    """Model for rate limiting (hour buckets)"""
    key = db.Column(db.String(255), primary_key=True)
    window_start = db.Column(db.DateTime, nullable=False)
    count = db.Column(db.Integer, nullable=False, default=0)
    
    def __repr__(self):
        return f'<RateLimit {self.key}: {self.count}>'
```

### 3. Authentication Utilities (auth_utils.py)
Helper functions for authentication operations:

```python
import hashlib
import secrets
import uuid
from datetime import datetime, timedelta
from functools import wraps
from flask import request, jsonify, session, g
from database import db
from auth_models import User, MagicLinkToken, Session as UserSession, RateLimit
import logging

logger = logging.getLogger(__name__)

def create_token():
    """Create a cryptographically secure token"""
    return secrets.token_urlsafe(32)

def hash_token(raw_token):
    """Hash token using SHA-256"""
    return hashlib.sha256(raw_token.encode('utf-8')).hexdigest()

def generate_uuid():
    """Generate a UUID string"""
    return str(uuid.uuid4())

def get_client_ip():
    """Get client IP address, handling proxies"""
    # Check X-Forwarded-For header first (for proxies)
    if request.headers.get('X-Forwarded-For'):
        return request.headers.get('X-Forwarded-For').split(',')[0].strip()
    # Check X-Real-IP header
    if request.headers.get('X-Real-IP'):
        return request.headers.get('X-Real-IP')
    # Fall back to remote_addr
    return request.remote_addr or ''

def check_rate_limit(key, limit_per_hour):
    """Check and update rate limit for a given key"""
    try:
        now = datetime.utcnow()
        # Create window start (beginning of current hour)
        window_start = now.replace(minute=0, second=0, microsecond=0)
        
        # Find or create rate limit record
        rate_limit = RateLimit.query.filter_by(key=key).first()
        
        if not rate_limit or rate_limit.window_start != window_start:
            # New window or first request
            if rate_limit:
                rate_limit.window_start = window_start
                rate_limit.count = 1
            else:
                rate_limit = RateLimit(
                    key=key,
                    window_start=window_start,
                    count=1
                )
                db.session.add(rate_limit)
            db.session.commit()
            return True
        
        # Check if limit exceeded
        if rate_limit.count >= limit_per_hour:
            return False
        
        # Increment count
        rate_limit.count += 1
        db.session.commit()
        return True
        
    except Exception as e:
        logger.error(f"Rate limit check failed for key {key}: {e}")
        db.session.rollback()
        # Fail open - allow request if rate limiting fails
        return True

def invalidate_previous_tokens(email):
    """Invalidate any previous active tokens for an email"""
    try:
        now = datetime.utcnow()
        MagicLinkToken.query.filter(
            MagicLinkToken.email == email,
            MagicLinkToken.consumed_at.is_(None),
            MagicLinkToken.expires_at > now
        ).update({'expires_at': now})
        db.session.commit()
    except Exception as e:
        logger.error(f"Failed to invalidate previous tokens for {email}: {e}")
        db.session.rollback()

def get_current_user():
    """Get current user from session"""
    try:
        session_id = request.cookies.get('sid')
        if not session_id:
            return None
        
        now = datetime.utcnow()
        user_session = UserSession.query.filter_by(id=session_id).first()
        
        if not user_session or user_session.expires_at < now:
            return None
        
        return user_session.user
    except Exception as e:
        logger.error(f"Failed to get current user: {e}")
        return None

def require_auth(f):
    """Decorator to require authentication"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        user = get_current_user()
        if not user:
            return jsonify({'error': 'Authentication required'}), 401
        g.current_user = user
        return f(*args, **kwargs)
    return decorated_function

def create_session(user_id):
    """Create a new session for a user"""
    session_id = secrets.token_urlsafe(32)
    expires_at = datetime.utcnow() + timedelta(days=30)
    
    user_session = UserSession(
        id=session_id,
        user_id=user_id,
        expires_at=expires_at
    )
    db.session.add(user_session)
    db.session.commit()
    
    return session_id, expires_at

def cleanup_expired_sessions():
    """Clean up expired sessions and tokens"""
    try:
        now = datetime.utcnow()
        
        # Clean up expired sessions
        UserSession.query.filter(UserSession.expires_at < now).delete()
        
        # Clean up expired tokens
        MagicLinkToken.query.filter(MagicLinkToken.expires_at < now).delete()
        
        db.session.commit()
        logger.info("Cleaned up expired sessions and tokens")
    except Exception as e:
        logger.error(f"Failed to cleanup expired data: {e}")
        db.session.rollback()
```

### 4. Email Service (email_service.py)
Sends magic link emails using Resend:

```python
import os
import logging
import resend

logger = logging.getLogger(__name__)

# Set API key
resend.api_key = os.environ.get('RESEND_API_KEY')

def send_magic_link_email(to_email, magic_link_url):
    """Send magic link email using Resend"""
    try:
        # Use environment variable for FROM address, with fallback
        from_email = os.environ.get('AUTH_FROM_EMAIL', 'Invoice Processor <noreply@receipts.theinstituteslab.org>')
        
        # Email content
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Sign in to Invoice Processor</title>
        </head>
        <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: #f8f9fa; padding: 30px; border-radius: 8px; text-align: center;">
                <h1 style="color: #0066cc; margin-bottom: 20px;">Invoice Processor</h1>
                <h2 style="color: #333; margin-bottom: 30px;">Sign in to your account</h2>
                
                <p style="font-size: 16px; margin-bottom: 30px;">Click the button below to securely sign in to your account:</p>
                
                <a href="{magic_link_url}" 
                   style="display: inline-block; background: #0066cc; color: white; padding: 15px 30px; text-decoration: none; border-radius: 5px; font-weight: bold; font-size: 16px;">
                    Sign In
                </a>
                
                <p style="font-size: 14px; color: #666; margin-top: 30px;">
                    This link expires in 15 minutes and can only be used once.
                </p>
                
                <p style="font-size: 12px; color: #999; margin-top: 20px;">
                    If you didn't request this email, you can safely ignore it.
                </p>
            </div>
        </body>
        </html>
        """
        
        text_content = f"""
        Sign in to Invoice Processor

        Click this link to sign in: {magic_link_url}

        This link expires in 15 minutes and can only be used once.

        If you didn't request this email, you can safely ignore it.
        """
        
        # Send email
        response = resend.Emails.send({
            "from": from_email,
            "to": [to_email],
            "subject": "Your sign-in link for Invoice Processor",
            "html": html_content,
            "text": text_content,
        })
        
        logger.info(f"Magic link email sent to {to_email}, response: {response}")
        return True
        
    except Exception as e:
        logger.error(f"Failed to send magic link email to {to_email}: {e}")
        return False
```

## API Endpoints

### Authentication Routes (auth_routes.py) - Part 1
Main authentication endpoints:

```python
import os
import logging
from datetime import datetime, timedelta
from flask import Blueprint, request, jsonify, make_response, redirect, url_for, render_template
from pydantic import BaseModel, EmailStr, ValidationError
from database import db
from auth_models import User, MagicLinkToken, Session as UserSession
from auth_utils import (
    create_token, hash_token, generate_uuid, get_client_ip, 
    check_rate_limit, invalidate_previous_tokens, create_session, get_current_user
)
from email_service import send_magic_link_email

logger = logging.getLogger(__name__)

# Create Blueprint for auth routes
auth_bp = Blueprint('auth', __name__, url_prefix='/api/auth')

class MagicLinkRequest(BaseModel):
    email: EmailStr

@auth_bp.route('/magic-link', methods=['POST'])
def request_magic_link():
    """Request a magic link for passwordless login"""
    try:
        # Parse and validate request
        data = request.get_json()
        if not data:
            return jsonify({'ok': False, 'error': 'Invalid request data'}), 400
        
        try:
            magic_link_req = MagicLinkRequest(**data)
            email = magic_link_req.email.lower().strip()
        except ValidationError as e:
            return jsonify({'ok': False, 'error': 'Invalid email address'}), 400
        
        # Get client info
        client_ip = get_client_ip()
        user_agent = request.headers.get('User-Agent', '')
        
        # Rate limiting
        email_key = f"send:email:{email}"
        ip_key = f"send:ip:{client_ip}"
        
        email_allowed = check_rate_limit(email_key, 3)  # 3 per hour per email
        ip_allowed = check_rate_limit(ip_key, 10)       # 10 per hour per IP
        
        if not email_allowed or not ip_allowed:
            # Return generic response to avoid user enumeration
            return jsonify({
                'ok': True, 
                'message': 'If that email is registered, we\'ve sent a sign-in link.'
            })
        
        # Invalidate any previous active tokens for this email
        invalidate_previous_tokens(email)
        
        # Create new token
        raw_token = create_token()
        token_hash = hash_token(raw_token)
        token_id = generate_uuid()
        expires_at = datetime.utcnow() + timedelta(minutes=15)
        
        # Save token to database
        magic_token = MagicLinkToken(
            id=token_id,
            email=email,
            token_hash=token_hash,
            expires_at=expires_at,
            created_ip=client_ip,
            user_agent=user_agent
        )
        
        db.session.add(magic_token)
        db.session.commit()
        
        # Generate magic link URL
        base_url = os.environ.get('APP_BASE_URL', 'http://localhost:5000')
        magic_link_url = f"{base_url}/api/auth/callback?token={raw_token}"
        
        # Send email
        email_sent = send_magic_link_email(email, magic_link_url)
        
        if not email_sent:
            logger.error(f"Failed to send magic link email to {email}")
        
        # Always return generic success message
        return jsonify({
            'ok': True,
            'message': 'If that email is registered, we\'ve sent a sign-in link.'
        })
        
    except Exception as e:
        logger.error(f"Error in magic link request: {e}")
        db.session.rollback()
        return jsonify({
            'ok': True,
            'message': 'If that email is registered, we\'ve sent a sign-in link.'
        })

@auth_bp.route('/callback', methods=['GET'])
def magic_link_callback():
    """Handle magic link callback and create session"""
    try:
        # Get token from query params
        raw_token = request.args.get('token', '').strip()
        if not raw_token:
            return render_template('auth_error.html', 
                                 error_type='invalid',
                                 message='Invalid sign-in link'), 400
        
        # Hash token to find in database
        token_hash = hash_token(raw_token)
        
        # Find token in database
        magic_token = MagicLinkToken.query.filter_by(token_hash=token_hash).first()
        
        if not magic_token:
            return render_template('auth_error.html', 
                                 error_type='invalid',
                                 message='Sign-in link not found or invalid'), 400
        
        # Check if already consumed
        if magic_token.consumed_at:
            return render_template('auth_error.html', 
                                 error_type='used',
                                 message='This sign-in link has already been used'), 400
        
        # Check if expired
        if magic_token.expires_at < datetime.utcnow():
            return render_template('auth_error.html', 
                                 error_type='expired',
                                 message='This sign-in link has expired'), 400
        
        # Just-in-time user provisioning
        user = User.query.filter_by(email=magic_token.email).first()
        if not user:
            user = User(
                id=generate_uuid(),
                email=magic_token.email
            )
            db.session.add(user)
            logger.info(f"Created new user account for {magic_token.email}")
        
        # Create session
        session_id, session_expires = create_session(user.id)
        
        # Mark token as consumed
        magic_token.consumed_at = datetime.utcnow()
        
        # Commit all changes
        db.session.commit()
        
        # Set session cookie
        response = make_response(redirect(url_for('index')))
        response.set_cookie(
            'sid',
            session_id,
            max_age=30 * 24 * 60 * 60,  # 30 days
            httponly=True,
            secure=True,
            samesite='Lax',
            path='/'
        )
        
        logger.info(f"User {magic_token.email} successfully signed in")
        return response
        
    except Exception as e:
        logger.error(f"Error in magic link callback: {e}")
        db.session.rollback()
        return render_template('auth_error.html', 
                             error_type='error',
                             message='An error occurred during sign-in'), 500

@auth_bp.route('/signout', methods=['POST'])
def signout():
    """Sign out user and clear session"""
    try:
        session_id = request.cookies.get('sid')
        if session_id:
            # Delete session from database
            UserSession.query.filter_by(id=session_id).delete()
            db.session.commit()
        
        # Clear session cookie
        response = make_response(jsonify({'ok': True}))
        response.set_cookie('sid', '', expires=0, path='/')
        
        return response
        
    except Exception as e:
        logger.error(f"Error during signout: {e}")
        db.session.rollback()
        return jsonify({'ok': False, 'error': 'Signout failed'}), 500

@auth_bp.route('/status', methods=['GET'])
def auth_status():
    """Get current authentication status"""
    try:
        user = get_current_user()
        if user:
            return jsonify({
                'authenticated': True,
                'email': user.email,
                'user_id': user.id
            })
        else:
            return jsonify({'authenticated': False})
    except Exception as e:
        logger.error(f"Error checking auth status: {e}")
        return jsonify({'authenticated': False}), 500
```

## Main Application Integration

### App.py Integration
Key parts for integrating authentication:

```python
import os
import logging
from flask import Flask, render_template, redirect, url_for
from werkzeug.middleware.proxy_fix import ProxyFix
from database import db
from auth_routes import auth_bp
from auth_utils import get_current_user, require_auth

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Create the app
app = Flask(__name__)

# Set secret key - use environment variable if available
app.secret_key = os.environ.get("SESSION_SECRET", "dev-secret-key-change-in-production-" + os.urandom(24).hex())
app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

# Configure the database
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ.get("DATABASE_URL")
app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
    "pool_recycle": 300,
    "pool_pre_ping": True,
}

# Initialize the app with the extension
db.init_app(app)

with app.app_context():
    # Import models here so their tables are created
    import auth_models  # noqa: F401
    db.create_all()

# Register auth blueprint
app.register_blueprint(auth_bp)

# Set environment variables for auth if not set
if not os.environ.get('AUTH_FROM_EMAIL'):
    os.environ['AUTH_FROM_EMAIL'] = 'Your App <noreply@yourdomain.com>'

@app.route('/login')
def login():
    """Login page for unauthenticated users"""
    return render_template('login.html')

@app.route('/')
def index():
    """Main page - requires authentication"""
    # Check authentication
    current_user = get_current_user()
    if not current_user:
        return redirect(url_for('login'))
    
    # User is authenticated, show the main dashboard
    return render_template('index.html', user=current_user)

# Protected API endpoint example
@app.route('/api/protected')
@require_auth
def protected_endpoint():
    """Example of a protected endpoint using decorator"""
    return jsonify({'message': 'This is protected data'})

if __name__ == '__main__':
    app.run(debug=True)
```

## Frontend Templates

### Login Page Template (templates/login.html)
Complete login page with client-side JavaScript:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sign In - Your App</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="bg-light">
    <div class="container d-flex align-items-center justify-content-center min-vh-100">
        <div class="row w-100">
            <div class="col-md-6 col-lg-4 mx-auto">
                <div class="card border-0 shadow">
                    <div class="card-body p-5">
                        <div class="text-center mb-4">
                            <h1>Your App</h1>
                            <p class="text-muted">Secure passwordless login</p>
                        </div>
                        
                        <form id="loginForm" onsubmit="requestMagicLink(event)">
                            <div class="mb-3">
                                <label for="email" class="form-label">Email</label>
                                <input type="email" class="form-control" id="email" 
                                       placeholder="Enter your email address" required>
                            </div>
                            
                            <div class="d-grid gap-2">
                                <button type="submit" class="btn btn-primary" id="loginBtn">
                                    <i class="fas fa-envelope me-2"></i>Email me a sign-in link
                                </button>
                            </div>
                        </form>
                        
                        <div id="loginMessage" class="mt-3" style="display: none;"></div>
                        
                        <div class="text-center mt-4">
                            <small class="text-muted">
                                <i class="fas fa-shield-alt me-1"></i>
                                We'll send you a secure link that expires in 15 minutes
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let cooldownTimer = null;
        
        async function requestMagicLink(event) {
            event.preventDefault();
            
            const email = document.getElementById('email').value;
            const loginBtn = document.getElementById('loginBtn');
            const messageDiv = document.getElementById('loginMessage');
            
            // Disable button and show loading
            loginBtn.disabled = true;
            loginBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Sending...';
            
            try {
                const response = await fetch('/api/auth/magic-link', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email: email })
                });
                
                const data = await response.json();
                
                if (data.ok) {
                    messageDiv.innerHTML = `
                        <div class="alert alert-success">
                            <i class="fas fa-check me-2"></i>
                            Check your email for a one-time sign-in link.
                            <br><small>Check your spam folder if you don't see it.</small>
                        </div>
                    `;
                    messageDiv.style.display = 'block';
                    
                    // Start 60-second cooldown
                    startCooldown();
                } else {
                    messageDiv.innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-times me-2"></i>
                            Failed to send email. Please try again.
                        </div>
                    `;
                    messageDiv.style.display = 'block';
                    
                    // Re-enable button
                    loginBtn.disabled = false;
                    loginBtn.innerHTML = '<i class="fas fa-envelope me-2"></i>Email me a sign-in link';
                }
            } catch (error) {
                messageDiv.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="fas fa-times me-2"></i>
                        Network error. Please try again.
                    </div>
                `;
                messageDiv.style.display = 'block';
                
                // Re-enable button
                loginBtn.disabled = false;
                loginBtn.innerHTML = '<i class="fas fa-envelope me-2"></i>Email me a sign-in link';
            }
        }
        
        function startCooldown() {
            let seconds = 60;
            const loginBtn = document.getElementById('loginBtn');
            
            function updateButton() {
                if (seconds > 0) {
                    loginBtn.innerHTML = `<i class="fas fa-clock me-2"></i>Wait ${seconds}s`;
                    loginBtn.disabled = true;
                    seconds--;
                    cooldownTimer = setTimeout(updateButton, 1000);
                } else {
                    loginBtn.innerHTML = '<i class="fas fa-envelope me-2"></i>Email me a sign-in link';
                    loginBtn.disabled = false;
                    cooldownTimer = null;
                }
            }
            
            updateButton();
        }
    </script>
</body>
</html>
```

### Error Page Template (templates/auth_error.html)
Handles authentication errors gracefully:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sign-in Error - Your App</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body class="bg-light">
    <div class="container d-flex align-items-center justify-content-center min-vh-100">
        <div class="row w-100">
            <div class="col-md-6 col-lg-4 mx-auto">
                <div class="card border-0 shadow">
                    <div class="card-body text-center p-5">
                        <div class="mb-4">
                            <i class="fas fa-exclamation-triangle text-warning" style="font-size: 3rem;"></i>
                        </div>
                        
                        <h2 class="card-title mb-3">Sign-in Issue</h2>
                        
                        <p class="mb-4">{{ message }}</p>
                        
                        {% if error_type == 'expired' or error_type == 'used' %}
                        <div class="d-grid gap-2">
                            <button class="btn btn-primary" onclick="showEmailForm()">
                                <i class="fas fa-envelope me-2"></i>Send a new link
                            </button>
                        </div>
                        
                        <div id="emailForm" class="mt-4" style="display: none;">
                            <form onsubmit="requestNewLink(event)">
                                <div class="mb-3">
                                    <input type="email" class="form-control" id="email" 
                                           placeholder="Enter your email address" required>
                                </div>
                                <div class="d-grid gap-2">
                                    <button type="submit" class="btn btn-success" id="sendBtn">
                                        <i class="fas fa-paper-plane me-2"></i>Send new link
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary" onclick="hideEmailForm()">
                                        Cancel
                                    </button>
                                </div>
                            </form>
                            <div id="sendMessage" class="mt-3" style="display: none;"></div>
                        </div>
                        {% else %}
                        <div class="d-grid gap-2">
                            <a href="{{ url_for('index') }}" class="btn btn-primary">
                                <i class="fas fa-home me-2"></i>Go to Home
                            </a>
                        </div>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        function showEmailForm() {
            document.getElementById('emailForm').style.display = 'block';
            document.getElementById('email').focus();
        }
        
        function hideEmailForm() {
            document.getElementById('emailForm').style.display = 'none';
            document.getElementById('sendMessage').style.display = 'none';
        }
        
        async function requestNewLink(event) {
            event.preventDefault();
            
            const email = document.getElementById('email').value;
            const sendBtn = document.getElementById('sendBtn');
            const messageDiv = document.getElementById('sendMessage');
            
            // Disable button and show loading
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Sending...';
            
            try {
                const response = await fetch('/api/auth/magic-link', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email: email })
                });
                
                const data = await response.json();
                
                if (data.ok) {
                    messageDiv.innerHTML = '<div class="alert alert-success"><i class="fas fa-check me-2"></i>' + data.message + '</div>';
                    messageDiv.style.display = 'block';
                    document.getElementById('email').value = '';
                } else {
                    messageDiv.innerHTML = '<div class="alert alert-danger"><i class="fas fa-times me-2"></i>Failed to send email. Please try again.</div>';
                    messageDiv.style.display = 'block';
                }
            } catch (error) {
                messageDiv.innerHTML = '<div class="alert alert-danger"><i class="fas fa-times me-2"></i>Network error. Please try again.</div>';
                messageDiv.style.display = 'block';
            }
            
            // Re-enable button
            sendBtn.disabled = false;
            sendBtn.innerHTML = '<i class="fas fa-paper-plane me-2"></i>Send new link';
        }
    </script>
</body>
</html>
```

## Environment Configuration

### Required Environment Variables
```bash
# Database Configuration
DATABASE_URL=postgresql://username:password@localhost/dbname

# Email Service (Resend)
RESEND_API_KEY=your_resend_api_key_here

# Email Settings
AUTH_FROM_EMAIL=Your App <noreply@yourdomain.com>

# Application URL (for magic links)
APP_BASE_URL=https://yourdomain.com  # Production
# APP_BASE_URL=http://localhost:5000  # Development

# Session Secret (generate a secure random string)
SESSION_SECRET=your-secure-random-secret-key-here
```

### Gunicorn Configuration (gunicorn_config.py)
```python
# Server socket
bind = "0.0.0.0:5000"

# Worker processes
workers = 1
worker_class = 'sync'

# Worker timeout (in seconds)
timeout = 300  # 5 minutes for processing

# Logging
loglevel = 'info'
accesslog = '-'
errorlog = '-'

# Reload on code changes (development only)
reload = True

# Reuse port
reuse_port = True
```

## Implementation Steps

### Step 1: Set Up Database
1. Create a PostgreSQL database
2. Set the DATABASE_URL environment variable
3. Run the application once to create tables automatically

### Step 2: Configure Resend Email Service
1. Sign up for a Resend account at https://resend.com
2. Get your API key from the dashboard
3. Set the RESEND_API_KEY environment variable
4. Configure your domain in Resend (optional but recommended)
5. Set AUTH_FROM_EMAIL with your verified domain

### Step 3: Create Project Structure
```bash
mkdir your-app
cd your-app

# Create directories
mkdir templates
mkdir static

# Create Python files
touch app.py
touch database.py
touch auth_models.py
touch auth_utils.py
touch auth_routes.py
touch email_service.py
touch gunicorn_config.py

# Create templates
touch templates/login.html
touch templates/auth_error.html
```

### Step 4: Install Dependencies
```bash
pip install flask flask-sqlalchemy werkzeug
pip install psycopg2-binary sqlalchemy
pip install resend pydantic email-validator
pip install gunicorn
```

### Step 5: Run the Application
```bash
# Development
python app.py

# Production with Gunicorn
gunicorn -c gunicorn_config.py app:app
```

## Security Considerations

### Token Security
- Tokens are hashed using SHA-256 before storage
- Raw tokens never stored in database
- Tokens expire after 15 minutes
- Single-use tokens (consumed on first use)

### Session Security
- HttpOnly cookies prevent JavaScript access
- Secure flag ensures HTTPS-only transmission
- SameSite=Lax prevents CSRF attacks
- 30-day expiration with server-side validation

### Rate Limiting
- 3 requests per hour per email address
- 10 requests per hour per IP address
- Hour-based sliding windows
- Prevents brute force and spam

### User Enumeration Prevention
- Always returns same message regardless of email existence
- No timing differences in responses
- Generic error messages

## Authentication Flow

### Login Flow
1. User enters email on login page
2. System validates email format
3. Rate limiting checks applied
4. Previous tokens invalidated
5. New token generated and hashed
6. Token saved to database with metadata
7. Magic link sent via email
8. Generic success message displayed

### Callback Flow
1. User clicks magic link in email
2. Token extracted from URL
3. Token hashed and looked up in database
4. Validation checks:
   - Token exists
   - Not already consumed
   - Not expired
5. User account created if doesn't exist (JIT provisioning)
6. Session created and saved to database
7. Session cookie set in response
8. User redirected to main application

### Session Validation
1. Every request checks for session cookie
2. Session looked up in database
3. Expiration checked
4. User object loaded if valid
5. Request proceeds or redirects to login

## Troubleshooting

### Common Issues

#### Emails Not Sending
- Check RESEND_API_KEY is set correctly
- Verify domain in Resend dashboard
- Check email logs in Resend dashboard
- Ensure AUTH_FROM_EMAIL uses verified domain

#### Sessions Not Persisting
- Check SESSION_SECRET is set
- Verify cookie domain settings
- Ensure HTTPS in production (secure=True)
- Check database connection

#### Rate Limiting Issues
- Clear rate_limit table if testing
- Adjust limits in check_rate_limit calls
- Check system clock synchronization

#### Token Expired Errors
- Increase token expiration time if needed
- Check server timezone settings
- Ensure database uses UTC timestamps

## Customization Options

### Modify Token Expiration
In `auth_routes.py`:
```python
expires_at = datetime.utcnow() + timedelta(minutes=30)  # Change from 15 to 30 minutes
```

### Adjust Rate Limits
In `auth_routes.py`:
```python
email_allowed = check_rate_limit(email_key, 5)  # Increase from 3 to 5 per hour
ip_allowed = check_rate_limit(ip_key, 20)       # Increase from 10 to 20 per hour
```

### Customize Email Template
Modify HTML and text content in `email_service.py`

### Change Session Duration
In `auth_utils.py`:
```python
expires_at = datetime.utcnow() + timedelta(days=7)  # Change from 30 to 7 days
```

## Conclusion
This implementation provides a secure, production-ready passwordless authentication system that can be easily integrated into any Flask application. The magic link approach eliminates password management complexity while maintaining high security standards through token hashing, rate limiting, and secure session management.